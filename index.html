<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI-Чат | Шокан Уалиханов</title>
    <style>
        :root {
    --color-main-bg: #EAEAEA;
    --color-accent: #7A5230;
    --color-text: #333333;
    --glass-blur: 15px;
    --glass-bg: rgba(255, 255, 255, 0.4);
    --glass-border: 1px solid rgba(255, 255, 255, 0.2);
}

* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    background: var(--color-main-bg);
    color: var(--color-text);
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    overflow: hidden;
}

.background-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, #F5E8D7 0%, #D7E8F5 100%);
    z-index: -1;
}

.chat-wrapper {
    width: 90%;
    max-width: 500px;
    padding: 30px;
    border-radius: 20px;
    z-index: 10;
}
.response-section {
    display: flex;
    align-items: flex-end;
    margin-bottom: 20px;
}

.profile-photo-container {
    padding-right: 15px;
    align-self: flex-end;
}

.profile-photo {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background-color: var(--color-accent);
    border: 2px solid white;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 0.6em;
    color: white;
    text-align: center;
    line-height: 1.2;
}

.message-window {
    flex-grow: 1;
    min-height: 100px;
    max-height: 400px;
    display: flex;
    align-items: flex-start;
    overflow: hidden;
    overflow-y: auto;
    
}

.response-bubble {
    padding: 15px 20px;
    border-radius: 20px 20px 20px 5px;
    max-width: 100%;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: none;
    opacity: 0;
    transform: scale(0.95) translateY(10px);
}

.glassmorphism {
    background: var(--glass-bg);
    border: var(--glass-border);
    backdrop-filter: blur(var(--glass-blur));
    -webkit-backdrop-filter: blur(var(--glass-blur));
}

#response-text {
    font-size: 1.1em;
    font-weight: 500;
}

.input-area {
    display: flex;
    border-radius: 12px;
    padding: 8px;
    background: rgba(255, 255, 255, 0.6);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
}

#user-input {
    flex-grow: 1;
    padding: 10px 15px;
    border: none;
    background: transparent;
    font-size: 1em;
    color: var(--color-text);
    outline: none;
    border-radius: 8px;
}

#user-input::placeholder {
    color: rgba(51, 51, 51, 0.7);
}

.send-button {
    width: 40px;
    height: 40px;
    background-color: var(--color-accent);
    border: none;
    border-radius: 8px;
    cursor: pointer;
    color: white;
    display: flex;
    justify-content: center;
    align-items: center;
    transition: background-color 0.2s, transform 0.1s;
    font-size: 1.1em;
}

.send-button:hover {
    background-color: #9C6A43;
}

.send-button:active {
    transform: scale(0.9);
}

.send-button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    background-color: #9C6A43;
}

#user-input:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

.fade-out {
    animation: fadeOut 0.3s ease-out forwards;
}

@keyframes fadeOut {
    to {
        opacity: 0;
        transform: scale(0.9) translateY(-10px);
    }
}

.fade-in {
    animation: fadeIn 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
}

@keyframes fadeIn {
    from {
        opacity: 0;
        transform: scale(0.95) translateY(10px);
    }
    to {
        opacity: 1;
        transform: scale(1) translateY(0);
    }
}
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body>
    <div class="background-overlay"></div> <div class="chat-wrapper">
        <div class="response-section">
            <div class="profile-photo-container">
                <div class="profile-photo" id="shokan-photo">
                    <img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSOeQfJcSOT3oH8uxz0i4_hSDfkVxJRrrCAfw&s" style="width: 100%; height: 100%; border-radius: 50%;" alt="">
                </div>
            </div>
            
            <div class="message-window">
                <div class="response-bubble glassmorphism" id="response-bubble">
                    <p id="response-text">ответ Шокана Уалиханов</p>
                </div>
            </div>
        </div>

        <div class="input-area glassmorphism">
            <input type="text" id="user-input" placeholder="введите сообщение" autofocus>
            <button id="send-button" class="send-button">
                <i class="fas fa-paper-plane"></i>
            </button>
        </div>
    </div>
    
    <script>

const responseBubble = document.getElementById("response-bubble");
const responseText   = document.getElementById("response-text");
const userInput      = document.getElementById("user-input");
const sendButton     = document.getElementById("send-button");

// Переменные для управления запросами
let isRequestInProgress = false;
let lastRequestTime = 0;
const MIN_REQUEST_INTERVAL = 1000; // Минимальный интервал между запросами (1 секунда)

/**
 * Функция для декодирования Base64 строки
 * @param {string} encoded - Закодированная в Base64 строка
 * @returns {string} - Декодированная строка
 */
function decodeBase64(encoded) {
    try {
        return atob(encoded);
    } catch (error) {
        console.error("Ошибка декодирования Base64:", error);
        return encoded; // Возвращаем исходную строку в случае ошибки
    }
}

/**
 * Функция для запроса к AIMLAPI (OpenAI-совместимый эндпоинт)
 * Сохраняем базовую защиту от частых запросов и повторов при 429.
 */
async function askAIML(prompt, retryCount = 0, maxRetries = 3) {
    // Предотвращаем одновременные запросы
    if (isRequestInProgress) {
        return "Пожалуйста, подождите. Обрабатывается предыдущий запрос...";
    }

    // Простая защита от слишком частых запросов
    const timeSinceLastRequest = Date.now() - lastRequestTime;
    if (timeSinceLastRequest < MIN_REQUEST_INTERVAL && lastRequestTime > 0) {
        const waitTime = MIN_REQUEST_INTERVAL - timeSinceLastRequest;
        await new Promise(resolve => setTimeout(resolve, waitTime));
    }

    isRequestInProgress = true;
    lastRequestTime = Date.now();

    try {
        // API ключ закодирован в Base64 для базовой защиты
        const encodedApiKey = "OGI4ODhiNDE2ZDYyNGJiMDhiZDU5NmI2NWYyNjdlMDA=";
        const apiKey = decodeBase64(encodedApiKey);
        const apiUrl = "https://api.aimlapi.com/v1/chat/completions";
        
        const res = await fetch(apiUrl, {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${apiKey}`
            },
            body: JSON.stringify({
                model: "gpt-4o",
                messages: [
                    {
                        role: "system",
                        content:
                            "Отвечай всегда в роли Шокана Уалиханова — казахского ученого, " +
                            "путешественника и офицера XIX века. Пиши в стиле того времени: " +
                            "уважительно, сдержанно, наблюдательно, с мудрыми размышлениями, " +
                            "но без чрезмерно длинных ответов. Говори так, будто обращаешься к собеседнику лично. " +
                            "Можешь не здороваться, если собеседник не здоровается сам."
                    },
                    { role: "user", content: prompt }
                ]
            })
        });

        // Проверяем статус ответа
        if (!res.ok) {
            const errorData = await res.json().catch(() => ({}));
            console.error("API Error:", res.status, errorData);
            
            if (res.status === 400) {
                isRequestInProgress = false;
                return "Ошибка запроса. Проверьте API ключ и параметры.";
            } else if (res.status === 403) {
                isRequestInProgress = false;
                return "Доступ запрещен. API ключ недействителен или истек.";
            } else if (res.status === 429) {
                // Обработка ошибки 429 (Too Many Requests)
                // ПРИЧИНЫ ОШИБКИ 429:
                // 1. Превышена квота API (quota) - бесплатный план Gemini имеет ограничения:
                //    - Лимит запросов в минуту (RPM - Requests Per Minute)
                //    - Лимит запросов в день (RPD - Requests Per Day)
                //    - Лимит токенов в минуту (TPM - Tokens Per Minute)
                // 2. Слишком частые запросы (rate limiting) - API блокирует при превышении скорости
                // 3. Превышен месячный лимит бесплатного плана
                // 4. Множественные одновременные запросы от одного API ключа
                
                const retryAfter = extractRetryAfter(errorData);
                const errorMessage = errorData?.error?.message || "";
                
                // Логируем детали ошибки для отладки
                console.error("429 Error Details:", {
                    message: errorMessage,
                    retryAfter: retryAfter,
                    errorData: errorData
                });
                
                if (retryCount < maxRetries) {
                    const waitTime = retryAfter || Math.min(1000 * Math.pow(2, retryCount), 30000);
                    console.log(`Rate limit exceeded. Retrying in ${waitTime}ms (attempt ${retryCount + 1}/${maxRetries})`);
                    
                    // Показываем пользователю информацию о повторе с объяснением
                    const waitSeconds = Math.ceil(waitTime / 1000);
                    let userMessage = `Превышен лимит запросов API.\n`;
                    userMessage += `Причина: ${errorMessage.includes('quota') ? 'Исчерпана квота запросов' : 'Слишком частые запросы'}\n`;
                    userMessage += `Повтор через ${waitSeconds} сек...`;
                    animateResponseText(userMessage);
                    
                    await new Promise(resolve => setTimeout(resolve, waitTime));
                    isRequestInProgress = false;
                    return askAIML(prompt, retryCount + 1, maxRetries);
                } else {
                    isRequestInProgress = false;
                    const waitSeconds = Math.ceil((retryAfter || 30000) / 1000);
                    let finalMessage = `Ошибка 429: Превышен лимит запросов.\n\n`;
                    finalMessage += `Возможные причины:\n`;
                    finalMessage += `• Исчерпана дневная квота бесплатного плана\n`;
                    finalMessage += `• Превышен лимит запросов в минуту\n`;
                    finalMessage += `• Превышен лимит токенов\n\n`;
                    finalMessage += `Решение:\n`;
                    finalMessage += `• Подождите ${waitSeconds} секунд\n`;
                    finalMessage += `• Проверьте квоту в Google Cloud Console\n`;
                    finalMessage += `• Рассмотрите переход на платный план`;
                    return finalMessage;
                }
            } else {
                isRequestInProgress = false;
                return `Ошибка сервера (${res.status}). Попробуйте позже.`;
            }
        }

        const data = await res.json();
        isRequestInProgress = false;

        return data?.choices?.[0]?.message?.content || "Ответа нет";

    } catch (err) {
        isRequestInProgress = false;
        console.error("Fetch Error:", err);
        
        // Определяем тип ошибки
        if (err.name === "TypeError" && err.message.includes("Failed to fetch")) {
            return "Ошибка подключения. Возможные причины:\n" +
                   "1. Проблемы с интернетом\n" +
                   "2. CORS блокировка (откройте через локальный сервер)\n" +
                   "3. Блокировка антивирусом/файрволом\n\n" +
                   "Решение: Запустите локальный сервер:\n" +
                   "python -m http.server 8000\n" +
                   "или\n" +
                   "npx http-server\n" +
                   "Затем откройте http://localhost:8000";
        } else if (err.name === "TypeError" && err.message.includes("network")) {
            return "Ошибка сети. Проверьте подключение к интернету.";
        } else {
            return `Ошибка: ${err.message || "Неизвестная ошибка"}`;
        }
    }
}

// Функция для извлечения времени повтора из ответа API
function extractRetryAfter(errorData) {
    // Пытаемся найти retry-after в разных местах ответа
    if (errorData?.error?.message) {
        const message = errorData.error.message;
        // Ищем паттерн "Please retry in X.XXs"
        const match = message.match(/retry in ([\d.]+)s/i);
        if (match) {
            const seconds = parseFloat(match[1]);
            return Math.ceil(seconds * 1000); // Конвертируем в миллисекунды
        }
    }
    
    // Если не нашли, используем экспоненциальную задержку
    return null;
}

function animateResponseText(newText) {
    responseBubble.classList.remove("fade-in");
    responseBubble.classList.add("fade-out");

    setTimeout(() => {
        responseText.textContent = newText;
        responseBubble.classList.remove("fade-out");
        responseBubble.classList.add("fade-in");
    }, 300);
}

async function sendMessage() {
    const text = userInput.value.trim();
    if (!text || isRequestInProgress) return;

    userInput.value = "";
    userInput.disabled = true;
    sendButton.disabled = true;
    
    // Показываем индикатор загрузки
    animateResponseText("Думаю...");

    try {
        const reply = await askAIML(text);
        animateResponseText(reply);
    } catch (err) {
        animateResponseText("Произошла ошибка. Проверьте консоль браузера (F12).");
        console.error("Send message error:", err);
    } finally {
        userInput.disabled = false;
        sendButton.disabled = false;
        userInput.focus();
    }
}

sendButton.addEventListener("click", sendMessage);
userInput.addEventListener("keydown", e => {
    if (e.key === "Enter") sendMessage();
});
    </script>
</body>

</html>

